#! /usr/local/bin/perl5 

#-------------------------------------------------------------------------------
# YARD-1 Linker
#-------------------------------------------------------------------------------


#-------------------------------------------------------------------------------
#
# Copyright (c) 2001,2007,2011, Brian Davis
#
# released under the "new BSD" license, see license/new_bsd.txt
#
#-------------------------------------------------------------------------------


#-------------------------------------------------------------------------------
#
#  General Notes:
#
#    - reads .obj file generated by yas.pl
#    - writes VHDL file with INIT_XX constants
#
#   currently, more of a memory image generator than a real linker
#
#  - linker output files:
#      - <file>.vh2 = VHDL file with INIT_XX constants
#      - <file>.vh1 = VHDL file with initialized array holding memory data
#      - <file>.cmd = YARDBUG command file to load program
#
#
#-------------------------------------------------------------------------------


#-------------------------------------------------------------------------------
#
# 'to do' list:
#
#    - add header line check for object format version
#
#    - add command line args for:
#       - memory image start/size 
#       - block RAM organization ( generate different INIT_XX records as needed )
#       - VHDL output file name and/or package name in VHDL file
#
#    - rewrite to use memory hash by address
#       - instead of iterating through fixed size array
#       - read everything into hash
#       - output one ( or more ) images from hash
#
#    - add other output formats:
#       - S-record or similar hex format
#       - EPIC command script for editing block RAM
#       - .coe for COREGEN created memories
#
#
#-------------------------------------------------------------------------------


my $VERSION = "0.0.2-alpha";

printf("\nYARD-1 Linker Version $VERSION\n");

# should have one argument, the object file
if ($#ARGV != 0) { die ("\nError: Expecting one (and only one) object file \n") };

$obj = $ARGV[0];  
$obj =~ s/\.obj$//g;

$obj_file = $obj . '.obj';
$cmd_file = $obj . '.cmd';
$vho_file = $obj . '.vh2';
$vhc_file = $obj . '.vh1';

open (OBJ_F, "$obj_file")  or die ("Can't open $obj_file: $!\n");

open (CMD_F, ">$cmd_file") or die ("Can't open $cmd_file: $!\n");
binmode CMD_F; # needed to enable writing solitary LF to file without CRLF expansion on Windows

open (VHO_F, ">$vho_file") or die ("Can't open $vho_file: $!\n");
open (VHC_F, ">$vhc_file") or die ("Can't open $vhc_file: $!\n");


#
# memory array definitions ( for INIT_XX attribute calculation )
#  currently hardcoded for a 2K byte RAM starting at zero
#  indexed by bytes
#  values stored as two digit hex string
#
$mem_init_value = "XX";
$mem_start = 0;

# 2K x 8 image ( 512x32 memory, four RAM4Bs)
#$mem_size  = 2048;

# 8K x 8 image (  2Kx32 memory, four RAM16Bs)
$mem_size  = 8192;

# $D1 turns debug prints on/off
$D1 = 0;

#
# initialize memory image array 
#
$mem_data[$mem_size-1] = $mem_init_value;
for($i=0 ; $i < $mem_size; $i++ ) { $mem_data[$i] = $mem_init_value;}

# clear other flags
$error = 0;

#
# Read .obj file, build memory image
#
 while ($line = <OBJ_F>)
   {
     chop $line; 

     if ($line =~ /#(.+)/) 
       { 
        # comment line, ignore
        # should check for proper header on first line of file
       }

     elsif ($line =~ /@(.+)/) 
       { 
         $address = oct ( "0x" . $1 );  
       }

     elsif($line =~ /op16=(.{4})$/) 
       { 
         $mem_data[ $address - $mem_start ]     = substr($1,0,2);
         $mem_data[ $address - $mem_start + 1 ] = substr($1,2,2);
         $address = $address + 2;
       }


     elsif ($line =~ /byte=(.{2})$/) 
       { 
         $mem_data[ $address - $mem_start ] = $1;
         $address = $address + 1;
       }

     elsif($line =~ /wyde=(.{4})$/) 
       { 
         $mem_data[ $address - $mem_start ]     = substr($1,0,2);
         $mem_data[ $address - $mem_start + 1 ] = substr($1,2,2);
         $address = $address + 2;
       }

     elsif($line =~ /quad=(.{8})$/) 
       { 
         $dat_str = substr($1,0,2);
         $mem_data[ $address - $mem_start ]     = $dat_str;

         $dat_str = substr($1,2,2);
         $mem_data[ $address - $mem_start + 1 ] = $dat_str;

         $dat_str = substr($1,4,2);
         $mem_data[ $address - $mem_start + 2 ] = $dat_str;

         $dat_str = substr($1,6,2);
         $mem_data[ $address - $mem_start + 3 ] = $dat_str;

         $address = $address + 4;
       }

   } # end while


#
# Write YARDBUG command file
#
$c_start = -1;

for($i=0 ; $i < $mem_size; $i++ )
 { 
    if ( $c_start == -1)
      {
        if ( $mem_data[$i] ne "XX" )
         {
          $c_start = $i;
          printf CMD_F ("M %08X %s ", $i,$mem_data[$i] );
         }
      }

    else
      {
        if ( $mem_data[$i] ne "XX" )
          {
            printf CMD_F ("%s ",  $mem_data[$i]);
          }

        if ( ( $mem_data[$i] eq "XX" ) || ( $i >= ($c_start + 15) ) )
          {
           $c_start = -1;
            printf CMD_F ("\x0A" ); # use explicit LF to avoid CR-LF echo induced RS232 buffer overrun
          }
      }
 } 

printf CMD_F ("\r\n" );



#
# Write VHDL constant array file
#

#
# vhdl constant array output file header/trailer
#
$vhc_file_header  = "--
-- Auto-generated by ylink.pl
--
library ieee;
use ieee.std_logic_1164.all;

package mem_dat_pkg is

  constant MEM_SIZE : natural := $mem_size ;

  type mem_type is array (0 to $mem_size - 1) of std_logic_vector (7 downto 0);

";

$vhc_file_trailer = "

end mem_dat_pkg;

";

$vhc_byte_trailer = "
     others => ( others => '0')
   );
";

#
# create output file boilerplate
#
print VHC_F $vhc_file_header;

#
# dump memory values to VHDL byte array ( dumps only byte locations being used )
#

for( $vhc_byte_offset=0 ; $vhc_byte_offset < 4 ; $vhc_byte_offset+=1 )
  {
    $vhc_mem_num = 3 - $vhc_byte_offset;

$vhc_byte_header  = "
  constant mem_dat_b$vhc_mem_num : mem_type  :=
   (
";

    print VHC_F $vhc_byte_header;

    for( $i=$vhc_byte_offset ; $i < $mem_size; $i+=4 )
     { 
       if ( ( $mem_data[$i] ne "XX" ) )
         {
           printf VHC_F ("  %12d => X\"%s\", \n", $i >> 2, $mem_data[$i] );
         }
     }

    print VHC_F $vhc_byte_trailer;

  }

#
# VHDL boilerplate to end memory array
#
print VHC_F $vhc_file_trailer;


#
# fill unused locations with zeroes before calculating INIT strings
#
for($i=0 ; $i < $mem_size; $i++ )
 { 
    if ( $mem_data[$i] eq "XX" )
      {
        $mem_data[$i]   = "00";
      }
 }

#
# Write VHDL blockram init file
#

#
# vhdl INIT output file header/trailer
#
$vho_file_header  = "--
-- Auto-generated by ylink.pl
--
library ieee;
use ieee.std_logic_1164.all;

package mem_init_pkg is

";

$vho_file_trailer = "

end mem_init_pkg;
";


# create output file boilerplate
print VHO_F $vho_file_header;

#
# BMD 4K BRAM
#
##  - currently hardcoded to read a 2K x 8 memory image array 
##  - writes INIT's for a 512 x 32 block RAM built from four RAMB4_S8_S8's
##
# $init_blks = 16;

#
# BMD 16K BRAM
#
#  - hardcoded to read a 8K x 8 memory image array 
#  - writes INIT's for a 2K x 32 block RAM built from four RAMB16_S9_S9's
#
 $init_blks = 64;


#
# generate INIT_XX strings 
#
 $init_blk_size = 32;
 $init_str_size = 64;

 for ( $i=0 ; $i < $init_blks; $i++ )  # INIT_00 through INIT_0F
   { 
     for ( $j=0 ; $j < $init_blk_size; $j++ )  # 32 quads (32 bit) per INIT block
       {
         # two hex chars. per word for each x8 BRAM; LSB value = last char in string
         $str_index = $init_str_size - ( $j*2 ) - 1;   

         # byte address in memory array
         $baddr = ( $i * $init_blk_size * 4 ) + ( $j * 4 );

         $s3[$str_index-1] = substr($mem_data[$baddr],   0, 1);
         $s3[$str_index]   = substr($mem_data[$baddr],   1, 1);

         $s2[$str_index-1] = substr($mem_data[$baddr+1], 0, 1);
         $s2[$str_index]   = substr($mem_data[$baddr+1], 1, 1);

         $s1[$str_index-1] = substr($mem_data[$baddr+2], 0, 1);
         $s1[$str_index]   = substr($mem_data[$baddr+2], 1, 1);

         $s0[$str_index-1] = substr($mem_data[$baddr+3], 0, 1);
         $s0[$str_index]   = substr($mem_data[$baddr+3], 1, 1);

         if ($D1) { printf ("INIT:  %d  %d  %d  %d  %s %s\n", $i, $j, $str_index, $baddr, $mem_data[$baddr],$mem_data[$baddr+1] ); }
         if ($D1) { printf ("INIT:  %d  %d  %d  %d  %s %s\n", $i, $j, $str_index-1, $baddr+1, $mem_data[$baddr+2], $mem_data[$baddr+3] ); }
       }

      printf VHO_F ("constant RAM3_INIT_%02X    : string     :=  \"%s\";\n", $i, join('', @s3) );
      printf VHO_F ("constant RAM2_INIT_%02X    : string     :=  \"%s\";\n", $i, join('', @s2) );
      printf VHO_F ("constant RAM1_INIT_%02X    : string     :=  \"%s\";\n", $i, join('', @s1) );
      printf VHO_F ("constant RAM0_INIT_%02X    : string     :=  \"%s\";\n", $i, join('', @s0) );
      printf VHO_F ("\n");
      printf VHO_F ("constant RAM3_BV_INIT_%02X : bit_vector := X\"%s\";\n", $i, join('', @s3) );
      printf VHO_F ("constant RAM2_BV_INIT_%02X : bit_vector := X\"%s\";\n", $i, join('', @s2) );
      printf VHO_F ("constant RAM1_BV_INIT_%02X : bit_vector := X\"%s\";\n", $i, join('', @s1) );
      printf VHO_F ("constant RAM0_BV_INIT_%02X : bit_vector := X\"%s\";\n", $i, join('', @s0) );
      printf VHO_F ("\n");

    }

# finish up output file boilerplate
print VHO_F $vho_file_trailer;


# tidy up
 close OBJ_F;
 close CMD_F;
 close VHO_F;
 close VHC_F;

 printf("\nTotal Errors = %d\n", $error);

 exit( $error_cnt > 0 );





